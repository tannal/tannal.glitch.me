数据库（或 DB）在计算机的最新发展中发挥了非常重要的作用。 当时，计算机基本上是巨型计算器，数据（姓名、电话号码）被认为是处理信息的剩余部分。 计算机刚刚开始商业化，当商界人士开始将它们用于现实世界时，这些剩余数据突然变得很重要。

在本文中，我们将经历理解问题并在 Go 中推导相应解决方案的过程。


在键值数据库中，对数据库的所有访问都是使用主键完成的。 通常，没有固定的模式或数据模型。 可以使用随机数据块来识别密钥。 当数据元素之间存在复杂关系或需要通过主键以外的方式查询数据时，键值存储“没有”用处。

元素可以是存储数据的任何单个“命名”单元，可能包含也可能不包含其他数据组件。

键值存储相对于 RDBMS 的优点：

灵活的数据建模：由于键值存储不会对数据强制实施任何结构，因此它为数据建模提供了巨大的灵活性，以满足应用程序的需求。
高性能：在许多场景中，键值架构可以比关系数据库具有更高的性能，因为在处理对象时不需要执行锁定、连接、联合或其他操作。 与传统的关系数据库不同，键值存储不需要搜索列或表来查找对象。 知道密钥将能够非常快速地定位对象。
大规模可扩展性：大多数键值数据库都可以使用商用硬件轻松按需扩展。 它们几乎可以增长到任何规模，而无需对数据库进行重大重新设计。
高可用性：与关系数据库相比，键值数据库可以更轻松、更简单地提供高可用性。 一些键值数据库使用无主分布式架构，消除单点故障以最大限度地提高弹性。
操作简单性：一些键值数据库专门设计用于简化操作，确保尽可能轻松地根据需要添加和删除容量，并且环境中的任何硬件或网络故障都不会造成停机。
键值存储更有意义的一些场景：

NoSQL数据库
存储整个区块链数据
缓存替换
推荐引擎内部
存储非常大的对象图
日志存储
用户个人资料数据
网址缩短器内部
目前最流行的一些键值存储有 BoltDB、Badger、LevelDB 等。

去年，我正在构建一个区块链协议，在设计该系统时，我发现几乎所有不同协议的现有区块链客户端都在使用键值存储来满足其存储需求。 除了在区块链中使用之外，构建数据库让我兴奋的是问题的复杂性，只能通过使用适当的数据结构和算法来解决，而且我很少有机会开发生产级系统软件 。

问题——优化磁盘搜索
寻道时间是硬件机制的特定部分在存储设备上定位特定信息所需的时间。 该值通常以毫秒 (ms) 表示，其中值越小表示寻道时间越快。

寻道时间并不是将文件复制到另一个硬盘驱动器、从互联网下载数据、将某些内容刻录到光盘等所需的总时间。

寻道时间通常称为访问时间，但实际上，访问时间比寻道时间要长一些，因为在查找数据和实际访问数据之间存在很小的延迟期。

因此，为了让数据库搜索特定数据，我们需要最小化搜索次数和时间。

解决方案——Btree
我们需要以能够加快磁盘写入和读取过程的方式存储数据。 在深入研究解决方案之前，让我们先思考一些随机出现的想法。 这里有几个：

逗号分隔记录
将所有内容存储在多个 JSON 文件中
基于XML的存储
将数据对象序列化到磁盘
我们可以使用任何方法来存储数据，但解释上面列出的每种方法的优缺点超出了本文的范围。 让我们直接走向我们的解决方案。

B 树是一种在数据库中放置和定位文件（称为记录或键）的方法。 B 树算法最大限度地减少了为查找所需记录而必须访问介质的次数，从而加快了处理速度。

当决策点（称为节点）位于硬盘上而不是在磁盘上时，B 树是首选

/写操作。 自平衡树（例如红黑树）可以很好地实现此目的。 我们的实现使用了一个跳跃列表。 如果收到请求时表中已经存在某个键，则该值将直接更新。 这与 LSM 树使用的其他数据结构不同，后者是不可变的。

删除也必须保留在表中。 存储逻辑删除非常重要，以防密钥仍包含 SST 中的数据。 稍后我们压缩 SST 文件时将解决删除问题。

最后，当 MemTable 达到某个阈值时，必须将其刷新到磁盘。 这里一个潜在的优化是分配一个新的 MemTable 并将当前 MemTable 指定为只读。 然后可以将旧表放在一边，以便后台作业写入磁盘。

预写日志
WAL 是一个纯文本文件，包含表上所有操作的转储。 本质上是 MemTable 上所有操作的事务日志。

这允许在服务重新启动时重建树的内存部分，以获取尚未刷新到 SST 的数据。

在我们的实现中，每个 MemTable 使用一个单独的 WAL 文件。 MemTable 写入磁盘后，其 WAL 文件将被清除，因为数据现在由 SST 保留在持久存储中。 这可以防止 WAL 无限增长。

排序字符串表
SST 文件是在磁盘上存储 LSM 树的主要数据表示形式。 每个都包含一系列按键排序的键/值：

SST文件

每个文件都是不可变的，从而更容易同时访问数据。

稀疏索引
稀疏索引可用于查找 SST 文件中包含的数据。 由于数据已排序，索引不需要包含所有键。 相反，它可能包括每第 N 个密钥。

海温指数

布隆过滤器
在检查 SST 之前，布隆过滤器用于确定 SST 是否可能包含密钥。 如果布隆过滤器找不到某个键，那么我们就知道该键不能包含在相应的 SST 中。

这有助于通过减少读取数据时的磁盘访问量来加快读取操作：

读

数据布局
等级
SST 文件被组织成从级别 0 开始的一系列多个级别。每个级别包含的数据都比上一个级别多，并且最大级别数是可配置的。

海事税 0 级

如上所示，级别 0 的文件可能包含重叠数据。 例如，观察第一个文件如何包含“Tucson”的密钥，而第二个文件中的第一个密钥是“Atlanta”。

这种排序是必要的，因为当 MemTable 达到容量时，文件是按需添加的。 问题是，为了找到 0 级中某个键的最新值，必须检查每个 SST 文件。 我们需要从最新的文件开始并返回到最旧的文件。

级别越高，安排的效率就越高。 考虑合并到级别 1 后的相同数据：

销售及服务税 1 级

正如您所看到的，数据保证在该级别的所有文件中按排序顺序排列。 可以使用二分搜索来查找包含给定密钥的 SST 文件。

因此，我们可能希望最小化 0 级的数据量，尤其是对于大型数据集。

每个后续 SST 级别将包含比前一个更多的数据。 由于每个后续级别包含的数据比前一个级别多一个数量级，因此不需要很多级别。

部分
数据在磁盘上被分成多个段，每个 SST 文件一个段。

每个段还包含一个标头（序列号）和一个索引。

堵塞
SST 内的数据被分为块。 每个块有一个稀疏索引。

SST 文件可以是二进制文件，可以选择压缩以节省空间。

合并
k-way合并算法用于将许多SST文件组合成一个新的SST级别。 或者也可以在单个 SST 级别内压缩数据。

该算法可以实现为流算法来处理大型数据集。 对于每个 SST 文件，可以将包含最新字符串和文件句柄的单个记录添加到堆中。 然后从堆中取出下一条记录，写入当前 SST 文件，并将源 SST 中的新记录与该 SST 文件中的下一个字符串添加回堆中。

在 keyva 中，合并是由 sst.Compact 实现的。

可以定期或按特定阈值合并数据。 例如，时间序列数据库可能会以特定时间间隔（每天、每小时等）合并数据。