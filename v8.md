# inbox


gn gen out/x64.release // eat args.gn

autoninja -C out/x64.release d8

ninja -C out/x64.release d8 -j -20



internal::Address It is an unsigned integer type that any valid pointer to void can be converted to this type (and back).
TaggedImpl is defined in src/objects/tagged-impl.h

class Object : public TaggedImpl<HeapObjectReferenceType::STRONG, Address> {

+------+
|Object|
|------|
|ptr_  |---->
+------+

ptr_ is a StorageType

FullObjectSlot slot = slot_at(kReturnValueIndex);

+----------+      +---------+
|ObjectSlot|      | Object  |
|----------|      |---------|
| address  | ---> |   18    |
+----------+      +---------+


Maybe
MaybeLocal
Data
Value
Handle

+----------+                  +--------+         +---------+
|  Handle  |                  | Object |         |   int   |
|----------|      +-----+     |--------|         |---------|
|*location_| ---> |&ptr_| --> | ptr_   | ----->  |     5   |
+----------+      +-----+     +--------+         +---------+

You also need to source v8/tools/gdbinit (for the same reason as Chromium, split debug info).

source tools/gdbinit

https://github.com/danbev/learning-v8?tab=readme-ov-file#handle a little bit outdated


p result

$1 = {<v8::internal::HandleBase> = {location_ = 0x55555575e7d8}, <No data fields>}

```js
// ./out/x64.debug/d8 -print-opt-code -print-bytecode -trace-opt -trace-deopt local/opt.js
// sudo perf  record  --call-graph=fp ./out/x64.debug/d8 -print-opt-code -print-bytecode -trace-opt -trace-deopt local/opt.js

// local/opt.js
function add(a, b) {
    return a + b;
  }
  
  function triggerOptimizations() {
    let result = 0;
  
    // Warm up phase to trigger optimization
    for (let i = 0; i < 10000; i++) {
      result = add(i, i);
    }
  
    // Triggering deoptimization by changing types
    result = add("1000", "2000");
  
    return result;
  }
  
  const finalResult = triggerOptimizations();
  console.log("Final Result: ", finalResult);
  
[generated bytecode for function:  (0x321d000d9c61 <SharedFunctionInfo>)]
Bytecode length: 43
Parameter count 1
Register count 5
Frame size 40
         0x5c200002150 @    0 : 13 00             LdaConstant [0]
         0x5c200002152 @    2 : c5                Star1
         0x5c200002153 @    3 : 19 fe f7          Mov <closure>, r2
    0 E> 0x5c200002156 @    6 : 65 68 01 f8 02    CallRuntime [DeclareGlobals], r1-r2
  376 S> 0x5c20000215b @   11 : 21 01 00          LdaGlobal [1], [0]
         0x5c20000215e @   14 : c5                Star1
  376 E> 0x5c20000215f @   15 : 61 f8 02          CallUndefinedReceiver0 r1, [2]
  376 E> 0x5c200002162 @   18 : 25 02             StaCurrentContextSlot [2]
  402 S> 0x5c200002164 @   20 : 21 02 04          LdaGlobal [2], [4]
         0x5c200002167 @   23 : c4                Star2
  410 E> 0x5c200002168 @   24 : 2d f7 03 06       GetNamedProperty r2, [3], [6]
         0x5c20000216c @   28 : c5                Star1
         0x5c20000216d @   29 : 13 04             LdaConstant [4]
         0x5c20000216f @   31 : c3                Star3
         0x5c200002170 @   32 : 17 02             LdaImmutableCurrentContextSlot [2]
         0x5c200002172 @   34 : c2                Star4
  410 E> 0x5c200002173 @   35 : 5f f8 f7 f6 f5 08 CallProperty2 r1, r2, r3, r4, [8]
         0x5c200002179 @   41 : c6                Star0
  448 S> 0x5c20000217a @   42 : ab                Return
Constant pool (size = 5)
0x321d000d9d51: [FixedArray] in OldSpace
 - map: 0x321d00000565 <Map(FIXED_ARRAY_TYPE)>
 - length: 5
           0: 0x321d000d9cb9 <FixedArray[4]>
           1: 0x321d000d9be5 <String[20]: #triggerOptimizations>
           2: 0x321d00004485 <String[7]: #console>
           3: 0x321d0030d35d <String[3]: #log>
           4: 0x321d000d9c31 <String[14]: #Final Result: >
Handler Table (size = 0)
Source Position Table (size = 20)
0x321d000d9d7d <ByteArray[20]>
[generated bytecode for function: triggerOptimizations (0x321d000d9d11 <SharedFunctionInfo triggerOptimizations>)]
Bytecode length: 49
Parameter count 1
Register count 5
Frame size 40
  116 S> 0x5c2000021a4 @    0 : 0c                LdaZero
         0x5c2000021a5 @    1 : c6                Star0
  184 S> 0x5c2000021a6 @    2 : 0c                LdaZero
         0x5c2000021a7 @    3 : c5                Star1
  189 S> 0x5c2000021a8 @    4 : 00 0d 10 27       LdaSmi.Wide [10000]
  189 E> 0x5c2000021ac @    8 : 6e f8 00          TestLessThan r1, [0]
         0x5c2000021af @   11 : 9b 15             JumpIfFalse [21] (0x5c2000021c4 @ 32)
  211 S> 0x5c2000021b1 @   13 : 21 00 01          LdaGlobal [0], [1]
         0x5c2000021b4 @   16 : c4                Star2
  220 E> 0x5c2000021b5 @   17 : 63 f7 f8 f8 03    CallUndefinedReceiver2 r2, r1, r1, [3]
         0x5c2000021ba @   22 : c6                Star0
  199 S> 0x5c2000021bb @   23 : 0b f8             Ldar r1
         0x5c2000021bd @   25 : 50 05             Inc [5]
         0x5c2000021bf @   27 : c5                Star1
  171 E> 0x5c2000021c0 @   28 : 8b 18 00 06       JumpLoop [24], [0], [6] (0x5c2000021a8 @ 4)
  295 S> 0x5c2000021c4 @   32 : 21 00 01          LdaGlobal [0], [1]
         0x5c2000021c7 @   35 : c4                Star2
         0x5c2000021c8 @   36 : 13 01             LdaConstant [1]
         0x5c2000021ca @   38 : c3                Star3
         0x5c2000021cb @   39 : 13 02             LdaConstant [2]
         0x5c2000021cd @   41 : c2                Star4
  304 E> 0x5c2000021ce @   42 : 63 f7 f6 f5 07    CallUndefinedReceiver2 r2, r3, r4, [7]
         0x5c2000021d3 @   47 : c6                Star0
  346 S> 0x5c2000021d4 @   48 : ab                Return
Constant pool (size = 3)
0x321d000d9eed: [FixedArray] in OldSpace
 - map: 0x321d00000565 <Map(FIXED_ARRAY_TYPE)>
 - length: 3
           0: 0x321d000040a1 <String[3]: #add>
           1: 0x321d000d9ea5 <String[4]: #1000>
           2: 0x321d000d9eb5 <String[4]: #2000>
Handler Table (size = 0)
Source Position Table (size = 28)
0x321d000d9f11 <ByteArray[28]>
[generated bytecode for function: add (0x321d000d9cd1 <SharedFunctionInfo add>)]
Bytecode length: 6
Parameter count 3
Register count 0
Frame size 0
   42 S> 0x5c200002200 @    0 : 0b 04             Ldar a1
   51 E> 0x5c200002202 @    2 : 38 03 00          Add a0, [0]
   55 S> 0x5c200002205 @    5 : ab                Return
Constant pool (size = 0)
Handler Table (size = 0)
Source Position Table (size = 8)
0x321d000d9f81 <ByteArray[8]>
[marking 0x321d000d9e05 <JSFunction add (sfi = 0x321d000d9cd1)> for optimization to MAGLEV, ConcurrencyMode::kConcurrent, reason: hot and stable]
[compiling method 0x321d000d9e05 <JSFunction add (sfi = 0x321d000d9cd1)> (target MAGLEV), mode: ConcurrencyMode::kConcurrent]
[completed compiling 0x321d000d9e05 <JSFunction add (sfi = 0x321d000d9cd1)> (target MAGLEV) - took 0.005, 2.303, 0.039 ms]
[marking 0x321d000d9e39 <JSFunction triggerOptimizations (sfi = 0x321d000d9d11)> for optimization to MAGLEV, ConcurrencyMode::kConcurrent, reason: hot and stable]
[compiling method 0x321d000d9e39 <JSFunction triggerOptimizations (sfi = 0x321d000d9d11)> (target MAGLEV) OSR, mode: ConcurrencyMode::kConcurrent]
[completed compiling 0x321d000d9e39 <JSFunction triggerOptimizations (sfi = 0x321d000d9d11)> (target MAGLEV) OSR - took 0.002, 1.882, 0.073 ms]
[compiling method 0x321d000d9e39 <JSFunction triggerOptimizations (sfi = 0x321d000d9d11)> (target TURBOFAN) OSR, mode: ConcurrencyMode::kConcurrent]
[bailout (kind: deopt-eager, reason: Insufficient type feedback for call): begin. deoptimizing 0x321d000d9e39 <JSFunction triggerOptimizations (sfi = 0x321d000d9d11)>, 0x321d00102549 <Code MAGLEV>, opt id 1, node id 0, bytecode offset 42, deopt exit 4, FP to SP delta 88, caller SP 0x7ffdc9a139e8, pc 0x7fe283ec4927]
[bailout (kind: deopt-eager, reason: not a Smi): begin. deoptimizing 0x321d000d9e05 <JSFunction add (sfi = 0x321d000d9cd1)>, 0x321d00102275 <Code MAGLEV>, opt id 0, node id 0, bytecode offset 2, deopt exit 0, FP to SP delta 24, caller SP 0x7ffdc9a13978, pc 0x7fe283ec437b]
Final Result:  10002000
```

execution stack

BaselineAssembler::EmitReturn call MacroAssembler::LeaveFrame
MacroAssembler::EnterFrame

Generate_JSConstructStubGeneric

This queue will be processed by the event loop when the call stack is empty.

memory management of the heap

Handle Tagged<Context> JSFunction JSObject JSReceiver

// 10.

Detaching the document loader

Isolate v8 instance sanboxed

multiple js applications runs in a isolate, need context

ObjecTemplate FunctionTemplate

VarInfo* function_info = GetVarInfo(function_name);

lib/internal/timers.js deps/uv/src/timer.c Maybe<ExitCode> SpinEventLoopInternal(Environment* env)

Environment* env

Isolate* isolate


function are like objects can have fields in js

```cpp

  /**
   * Adds a property to each instance created by this template.
   *
   * The property must be defined either as a primitive value, or a template.
   */
  void Set(Local<Name> name, Local<Data> value,
           PropertyAttribute attributes = None);

class V8_EXPORT Name : public Primitive {}

class V8_EXPORT Data {}

```

v8-xx.h
# C++ language features used in v8

using keyword

# labs

```bash

# task.js
console.log('main...');

function something() {
  setTimeout(() => console.log('something'), 0);
}

something();

console.log('main...done');

env NODE_DEBUG=timer ./node local/task.js

```

# Get the code

```bash
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git

export PATH=/home/tannal/tannalwork/projects/depot_tools:$PATH

mkdir v8 && cd v8

fetch v8

./tools/dev/gm.py x64.release
./tools/dev/gm.py x64.debug

tools/dev/update-compile-commands.py

# autoninja -C out/x64.debug d8
ninja: Entering directory `out/x64.debug'
[2477/2477] LINK ./d8

real	8m57.143s
user	198m43.792s
sys	7m56.004s

# .vsocde/launch.json

{
    "configurations": [
    {
        "type": "lldb",
        "request": "launch",
        "name": "Launch",
        "program": "${workspaceFolder}/out/x64.debug/d8",
        "args": ["${workspaceFolder}/local/task.js"],
        "sourceMap": {
            "../../": "${workspaceFolder}"
        },
        "breakpointMode": "file",
        "cwd": "${workspaceFolder}"
    }
    ]
}


autoninja -C out/x64.release torque-language-server
autoninja -C out/x64.debug torque-language-server


git switch main

git pull

```
```js
// add.js
// out/x64.debug/d8 --print-ast add.js

function add(x, y) {
    return x + y;
}

console.log(add(1, 2));
// out/x64.debug/d8 --print-ast add.js

[generating bytecode for function: ]
--- AST ---
FUNC at 0
. KIND 0
. LITERAL ID 0
. SUSPEND COUNT 0
. NAME ""
. INFERRED NAME ""
. DECLS
. . FUNCTION "add" = function add
. EXPRESSION STATEMENT at 78
. . ASSIGN at -1
. . . VAR PROXY local[0] (0x5604fcb32bf0) (mode = TEMPORARY, assigned = true) ".result"
. . . CALL
. . . . PROPERTY at 86
. . . . . VAR PROXY unallocated (0x5604fcb32cb0) (mode = DYNAMIC_GLOBAL, assigned = false) "console"
. . . . . NAME log
. . . . CALL
. . . . . VAR PROXY unallocated (0x5604fcb32a80) (mode = VAR, assigned = true) "add"
. . . . . LITERAL 1
. . . . . LITERAL 2
. RETURN at -1
. . VAR PROXY local[0] (0x5604fcb32bf0) (mode = TEMPORARY, assigned = true) ".result"

[generating bytecode for function: add]
--- AST ---
FUNC at 48
. KIND 0
. LITERAL ID 1
. SUSPEND COUNT 0
. NAME "add"
. PARAMS
. . VAR (0x5604fcb32b10) (mode = VAR, assigned = false) "x"
. . VAR (0x5604fcb32b90) (mode = VAR, assigned = false) "y"
. DECLS
. . VARIABLE (0x5604fcb32b10) (mode = VAR, assigned = false) "x"
. . VARIABLE (0x5604fcb32b90) (mode = VAR, assigned = false) "y"
. RETURN at 61
. . ADD at 70
. . . VAR PROXY parameter[0] (0x5604fcb32b10) (mode = VAR, assigned = false) "x"
. . . VAR PROXY parameter[1] (0x5604fcb32b90) (mode = VAR, assigned = false) "y"
```

var proxy


# debugging

breakpoints



# dev branch

git push --set-upstream origin dev

# GPT QA

```bash
I'm reading v8 source code.
Which cpp files or class is considered top 10 for understanding v8 and add new ecmaScript features, why?

```

## v8 general ecmaScript features

src/objects/js-objects.cc: This file contains the implementation of JavaScript objects in V8, including basic object operations and behavior.

src/interpreter/interpreter.cc: The interpreter module provides an execution environment for JavaScript code, and this file contains the core logic for interpreting JavaScript bytecode.

src/runtime/runtime.cc: This file houses the implementation of various built-in JavaScript functions and runtime operations, such as object creation, property access, and function invocation.

src/compiler/pipeline.cc: The compiler pipeline is responsible for translating JavaScript code into optimized machine code. Understanding this file helps grasp the compilation process in V8.

src/builtins/builtins.cc: This file contains the implementations of built-in JavaScript functions, which are essential for adding new ECMAScript features or extending existing ones.

src/objects/js-array.cc: Arrays are a fundamental data structure in JavaScript. This file covers the implementation details of JavaScript arrays in V8.

src/objects/js-function.cc: JavaScript functions play a vital role in V8, and this file contains the implementation of JavaScript function objects.

src/objects/js-regexp.cc: Regular expressions are extensively used in JavaScript. This file provides insights into the implementation of regular expressions in V8.

src/objects/js-weak-refs.cc: Weak references are a more advanced feature in JavaScript. This file covers the implementation of weak references in V8 and can be relevant when adding new features related to memory management.

src/api/api.cc: The V8 API is the interface that allows embedding V8 into other applications. Understanding this file helps when extending V8's functionality or integrating it with other systems.

## memory management & garbage collection

src/heap/heap.h and src/heap/heap.cc: These files define the overall structure and behavior of V8's heap, which is responsible for managing memory allocations. Understanding these files gives you insights into how V8 organizes and manages memory.

src/heap/spaces.h and src/heap/spaces.cc: These files define the different memory spaces within the V8 heap, such as new space, old space, and large object space. Each space has its own garbage collection characteristics and policies.

src/heap/gc-tracer.h: This file defines the interface for garbage collection tracers, which are used to analyze the heap and gather data during garbage collection cycles. Tracers are essential for profiling and understanding memory usage in V8.

src/heap/mark-compact.cc: The mark-compact garbage collector is one of the garbage collection algorithms used in V8. This file contains the implementation of the mark-compact collector, which performs marking and compaction of memory during garbage collection.

src/heap/scavenger.cc: The scavenger is another garbage collection algorithm employed by V8. This file contains the implementation of the scavenger, which collects objects in the new space.

src/heap/spaces-inl.h: This file provides inline functions and utilities related to memory spaces, such as allocation and garbage collection operations specific to each space.

src/objects/heap-object.h: This header file defines the base class for objects within the V8 heap. Understanding this class helps you grasp the common properties and behavior of objects managed by the garbage collector.

src/objects/slots.h: Slots are used to store object properties and elements. This file defines the class for slots, which is crucial for understanding how objects' properties are stored and accessed by the garbage collector.

src/objects/api-objects.h: This header file contains the definition of API objects, which are objects that can be accessed and manipulated from JavaScript code. Understanding this class helps when extending V8's memory management capabilities in the context of the public API.

src/objects/map.h and src/objects/map.cc: Maps represent the structure and shape of objects in V8. These files define the Map class, which is essential for understanding how object layouts are managed and updated during garbage collection.

## webassebmly in v8

src/wasm: The src/wasm directory contains the core implementation of WebAssembly in V8. It includes files such as src/wasm/module.h, src/wasm/module.cc, src/wasm/interpreter.cc, src/wasm/wasm-code.cc, and others. This directory provides an in-depth understanding of how V8 handles WebAssembly modules, bytecode interpretation, and code generation.

src/api/api-arguments.cc: This file contains the implementation of the V8 API for working with WebAssembly arguments and function calls. Understanding this file is crucial for leveraging WebAssembly functionality in V8 through the public API.

src/api/api-objects.cc: The api-objects.cc file houses the implementation of WebAssembly-related objects in the V8 API, such as WebAssembly.Module, WebAssembly.Instance, and WebAssembly.Memory. This file is essential for understanding the V8 API's support for WebAssembly.

src/wasm/function-compiler.cc: This file contains the implementation of the WebAssembly function compiler in V8. It covers the process of translating WebAssembly functions to V8's internal representation and optimizing them for execution.

src/wasm/wasm-objects.cc: The wasm-objects.cc file defines the internal representations of WebAssembly objects in V8, including WebAssembly functions, tables, memories, and globals. Understanding this file helps you grasp how V8 handles WebAssembly-specific object types.

src/wasm/wasm-engine.cc: This file contains the core engine for executing WebAssembly code in V8. It covers aspects such as module instantiation, function invocation, and memory management for WebAssembly.

src/wasm/wasm-js.cc: The wasm-js.cc file bridges the gap between WebAssembly and JavaScript in V8. It provides the glue code for interacting with WebAssembly modules from JavaScript, including imports, exports, and interoperation between the two.

src/wasm/wasm-compiler.cc: This file houses the WebAssembly compiler in V8, responsible for translating WebAssembly bytecode to optimized machine code. Understanding this file is crucial for adding new WebAssembly features and optimizing the compilation process.

src/wasm/wasm-module-builder.cc: The wasm-module-builder.cc file provides utilities for constructing WebAssembly modules programmatically. It can be helpful when adding new features that involve dynamically generating WebAssembly modules.

src/wasm/wasm-link.cc: This file handles the linking of WebAssembly modules in V8. It allows you to link multiple WebAssembly modules together, sharing functions and memories between them. Understanding this file is useful when working with modular WebAssembly code.


# code generation & builtin torque

src/torque/: The Torque directory contains the definition of V8's intermediate representation (IR) and the associated toolchain. It includes files such as src/torque/ast/, src/torque/interpreter/, src/torque/lowering/, src/torque/typer/, and more. Understanding the Torque directory is crucial for comprehending V8's code generation pipeline.

src/codegen/: The codegen directory houses the code generation infrastructure in V8, including files like src/codegen/assembler.cc, src/codegen/code-factory.cc, src/codegen/code-stub-assembler.cc, and others. Exploring this directory will provide insights into how V8 generates machine code.

src/compiler/: The compiler directory contains files related to V8's optimizing compiler, known as TurboFan. It includes files like src/compiler/compiler.cc, src/compiler/graph/, src/compiler/js-graph/, src/compiler/simplified-lowering.cc, and more. Understanding this directory is essential for gaining insights into V8's advanced code generation techniques.

src/builtins/: The builtins directory contains the implementation of built-in JavaScript functions in V8. It includes files like src/builtins/builtins-definitions.h, src/builtins/builtins-array.cc, src/builtins/builtins-math.cc, and others. Exploring this directory will help you understand how to add new built-in functions and extend V8's code generation for them.

src/objects/: The objects directory contains files related to JavaScript objects in V8. It includes files like src/objects/js-object.cc, src/objects/js-array.cc, src/objects/js-function.cc, and more. Understanding this directory is essential for understanding the objects that V8 generates code for and how they are represented internally.

src/interpreter/: The interpreter directory contains files related to V8's bytecode interpreter. It includes files like src/interpreter/bytecode-array-builder.cc, src/interpreter/bytecode-array-writer.cc, src/interpreter/bytecode-decoder.cc, and others. Understanding the interpreter is valuable for comprehending V8's code generation process for executing JavaScript code.

src/api/: The API directory contains files related to V8's public API. It includes files like src/api/api-arguments.cc, src/api/api-function.cc, src/api/api-object.cc, and more. Understanding this directory is useful for adding new code generation features that are accessible through the V8 API.

src/compiler/pipeline.cc: The pipeline.cc file is responsible for coordinating V8's compiler pipeline, which includes various stages of optimization and code generation. Understanding this file helps you grasp the overall flow of V8's code generation process.

src/compiler/machine-operator.h: This header file defines the base class for machine operators used in V8's code generation. It provides a foundation for understanding how operations are represented and transformed during code generation.

src/compiler/simplified-operator.h: This header file defines the base class for simplified operators used in V8's code generation. Simplified operators represent high-level operations that are later transformed into machine instructions.


## v8 chromium interaction

src/inspector/: The inspector directory contains files related to V8's integration with the Chromium DevTools protocol, which allows for debugging and profiling of V8-based applications. It includes files like src/inspector/inspector_agent.cc, src/inspector/inspector_io.cc, src/inspector/inspector_socket.cc, and more. Understanding this directory is crucial for extending V8's interaction with Chromium's debugging and profiling capabilities.

src/heap/: The heap directory contains files related to V8's memory management and garbage collection. It includes files like src/heap/heap.cc, src/heap/spaces.h, src/heap/gc-tracer.h, and others. Understanding this directory is important for managing memory effectively and integrating V8's garbage collection with Chromium's memory management.

src/api/: The API directory contains files related to V8's public API. It includes files like src/api/api.cc, src/api/api-function.cc, src/api/api-object.cc, and more. Understanding this directory is crucial for extending V8's capabilities and integrating with Chromium's APIs.

src/objects/: The objects directory contains files related to JavaScript objects in V8. It includes files like src/objects/js-object.cc, src/objects/js-array.cc, src/objects/js-function.cc, and more. Understanding this directory is important for working with JavaScript objects and integrating them with Chromium's DOM and other native APIs.

src/interpreter/: The interpreter directory contains files related to V8's bytecode interpreter. It includes files like src/interpreter/bytecode-array-builder.cc, src/interpreter/bytecode-array-writer.cc, src/interpreter/bytecode-decoder.cc, and others. Understanding this directory helps in integrating V8's interpreter with Chromium's execution environment.

src/execution/: The execution directory contains files related to V8's execution pipeline. It includes files like src/execution/execution.cc, src/execution/execution-context.cc, src/execution/isolate.cc, and more. Understanding this directory is important for integrating V8's execution with Chromium's overall execution environment.

src/base/: The base directory contains fundamental infrastructure files used by V8. It includes files like src/base/logging.cc, src/base/macros.h, src/base/platform/platform.cc, and more. Understanding this directory is crucial for integrating V8 with Chromium's platform-specific features and APIs.

src/debug/: The debug directory contains files related to V8's debugging support. It includes files like src/debug/debug-interface.cc, src/debug/debug-coverage.cc, src/debug/debug-objects.cc, and others. Understanding this directory is important for integrating V8's debugging capabilities with Chromium's developer tools.

src/zone/: The zone directory contains files related to V8's zone allocation system, which allows for efficient allocation and deallocation of memory within specific regions. It includes files like src/zone/zone.cc, src/zone/zone-allocator.cc, src/zone/zone-containers.cc, and more. Understanding this directory is important for managing memory efficiently and integrating V8's zone system with Chromium's memory management.

src/external-reference-table.h: This header file defines the interface for the external reference table used by V8. It allows for efficient management of external references, which can be utilized when integrating V8 with Chromium's native APIs.

## src/compiler/: The compiler directory contains files related to V8's optimizing compiler, known as TurboFan. It includes files like src/compiler/compiler.cc, src/compiler/graph/, src/compiler/js-graph/, src/compiler/simplified-lowering.cc, and more. Understanding this directory is crucial for comprehending V8's JIT compilation pipeline and adding new JIT compiler features.

src/codegen/: The codegen directory houses the code generation infrastructure in V8, including files like src/codegen/assembler.cc, src/codegen/code-factory.cc, src/codegen/code-stub-assembler.cc, and others. Exploring this directory will provide insights into how V8 generates machine code in the JIT compilation process.

src/full-codegen/: The full-codegen directory contains files related to V8's full-codegen compiler, which is a simpler, non-optimizing compiler used for older JavaScript code. It includes files like src/full-codegen/full-codegen.cc, src/full-codegen/full-codegen.h, and others. Understanding this directory can help you understand the basics of V8's code generation and how it differs from the optimizing compiler.

src/compiler/pipeline.cc: The pipeline.cc file is responsible for coordinating V8's compiler pipeline, which includes various stages of optimization and code generation. Understanding this file helps you grasp the overall flow of V8's JIT compilation process and how different stages interact.

src/compiler/machine-operator.h: This header file defines the base class for machine operators used in V8's code generation. It provides a foundation for understanding how operations are represented and transformed during JIT compilation.

src/compiler/simplified-operator.h: This header file defines the base class for simplified operators used in V8's code generation. Simplified operators represent high-level operations that are later transformed into machine instructions. Understanding this file is important for understanding the intermediate representation used in V8's JIT compilation.

src/interpreter/: The interpreter directory contains files related to V8's bytecode interpreter. It includes files like src/interpreter/bytecode-array-builder.cc, src/interpreter/bytecode-array-writer.cc, src/interpreter/bytecode-decoder.cc, and others. Understanding the interpreter is valuable for comprehending how V8's JIT compilation interacts with the bytecode representation of JavaScript code.

src/objects/: The objects directory contains files related to JavaScript objects in V8. It includes files like src/objects/js-object.cc, src/objects/js-array.cc, src/objects/js-function.cc, and more. Understanding this directory is essential for understanding how V8's JIT compiler interacts with JavaScript objects and their representation in memory.

src/api/: The API directory contains files related to V8's public API. It includes files like src/api/api.cc, src/api/api-function.cc, src/api/api-object.cc, and more. Understanding this directory is important for extending V8's JIT compiler features and exposing them through the V8 API.

src/heap/: The heap directory contains files related to V8's memory management and garbage collection. It includes files like src/heap/heap.cc, src/heap/spaces.h, src/heap/gc-tracer.h, and others. Understanding this directory is important for managing memory efficiently within the context of the JIT compilation process.

# builtins torque

.tq file is like Typescript in v8

we can use debug print to print value

Print itself is basically for diagnostic

see src/diagnostics/objects-printer.cc

most ecmascript implementation in .tq files

fast path & object shape optimization in v8

CodeStubAssembler

builtins handwriting assembly

TurboFan optimizing compiler

.js -> .tq

calls to V8’s C++ code via trampolines

by taking advantage of V8’s custom register-based ABI that it uses internally to call JavaScript functions.


# JsArray in v8

src/objects/js-array.h
src/objects/context.h

elements FixedArray in src/objects/fixed-array.h

IsCowArray

```js

const arr = [1, 2, 3, 4]

DebugPrint: 0x1cb3001c9459: [JSArray]
 # PrintHeader
 - map: 0x1cb3000ce6b1 <Map[16](PACKED_SMI_ELEMENTS)> [FastProperties]

 # JSObjectPrintHeader
 - prototype: 0x1cb3000ce925 <JSArray[0]>
 - elements: 0x1cb3000d9c39 <FixedArray[4]> [PACKED_SMI_ELEMENTS (COW)]
 - length: 4
 - properties: 0x1cb3000006cd <FixedArray[0]>
 - All own properties (excluding elements): {
    0x1cb300000d41: [String] in ReadOnlySpace: #length: 0x1cb30030ed25 <AccessorInfo name= 0x1cb300000d41 <String[6]: #length>, data= 0x1cb300000061 <undefined>> (const accessor descriptor), location: descriptor
 }
 - elements: 0x1cb3000d9c39 <FixedArray[4]> {
           0: 1
           1: 2
           2: 3
           3: 4
 }

# PrintHeapObjectHeaderWithoutMap
0x1cb3000ce6b1: [Map] in OldSpace

# Map::MapPrint
 - map: 0x1cb3000c3c29 <MetaMap (0x1cb3000c3c79 <NativeContext[285]>)>
 - type: JS_ARRAY_TYPE
 - instance size: 16
 - inobject properties: 0
 - unused property fields: 0
 - elements kind: PACKED_SMI_ELEMENTS
 - enum length: invalid
 - back pointer: 0x1cb300000061 <undefined>
 - prototype_validity cell: 0x1cb300000a31 <Cell value= 1>
 - instance descriptors #1: 0x1cb3000cef3d <DescriptorArray[1]>
 - transitions #1: 0x1cb3000cef59 <TransitionArray[4]>Transition array #1:
     0x1cb300000e05 <Symbol: (elements_transition_symbol)>: (transition to HOLEY_SMI_ELEMENTS) -> 0x1cb3000cef71 <Map[16](HOLEY_SMI_ELEMENTS)>

 - prototype: 0x1cb3000ce925 <JSArray[0]>
 - constructor: 0x1cb3000ce61d <JSFunction Array (sfi = 0x1cb30033538d)>
 - dependent code: 0x1cb3000006dd <Other heap object (WEAK_ARRAY_LIST_TYPE)>
 - construction counter: 0


```


Object in programming language is just a collection of properties and methods.


So js Array in V8 has a bunch of properties like

map 


# reference

https://github.com/danbev/learning-v8

# community

https://groups.google.com/g/v8-dev

https://groups.google.com/g/v8-users

https://www.mail-archive.com/search?q=trampoline&l=v8-dev%40googlegroups.com