<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="icon" href="https://glitch.com/favicon.ico" />
    <title>Bringing the Web up to Speed with WebAssembly</title>
    <link rel="stylesheet" href="./paper.css" />
    <style>
      body {
        font-size: 0.335cm;
        line-height: 0.44cm;
      }

      .title {
        text-align: center;
        font-size: 0.5cm;
        font-weight: 600;
      }

      .authors {
        display: grid;
        grid-template-columns: auto auto;
        text-align: center;
      }

      .float-right {
        float: right;
      }

      article {
        display: flex;
        gap: 1em;
      }

      article > section {
        flex: 1 1 0;
      }

      .heading-1 {
        font-weight: 600;
      }

      .heading-2 {
        font-weight: 600;
      }

      figcaption {
        text-align: center;
      }

      .figure-table {
        display: grid;
        grid-template-columns: auto auto;
        gap: 0.5em;
      }

      figure {
        /* font-size: 0.3cm; */
      }

      .half {
        width: 50%;
        margin: 0;
      }

      footer {
        font-size: 0.27cm;
      }

      .code {
        display: flex;
        font-size: 0.24cm;
        align-items: center;
        gap: 0.5em;
      }
    </style>
  </head>

  <body>
    <page size="A4">
      <h3 class="title">A Tour of Webassembly</h3>
      <section class="authors">
        <div>
          <p>Andreas Haas Andreas Rossberg Derek L. Schuff∗ Ben L. Titzer</p>
          <p>Google GmbH, Germany / ∗Google Inc, USA</p>
          <p>{ahaas,rossberg,dschuff,titzer}@google.com</p>
        </div>

        <div>
          <p>Michael Holman</p>
          <p>Microsoft Inc, USA</p>
          <p>michael.holman@microsoft.com</p>
        </div>

        <div>
          <p>Dan Gohman Luke Wagner Alon Zakai</p>
          <p>Mozilla Inc, USA</p>
          <p>{sunfishcode,luke,azakai}@mozilla.com</p>
        </div>

        <div>
          <p>JF Bastien</p>
          <p>Apple Inc, USA</p>
          <p>jfbastien@apple.com</p>
        </div>
      </section>
      <article>
        <section>
          <header class="heading-1">Abstract</header>
          <p>
            For a long time, JavaScript is the only language that can run on the
            web. People usually use extra tools compile other languages to
            JavaScript. In this paper, we review Webassembly and put it in the
            context of modern web environment. We compare Webassembly and
            JavaScript as a compiplation target for both client and server
            workloads. and finally comment on observed use-cases of Webassembly
            in academia and industry.
          </p>
          <p>
            WebAssembly is a new binary format and runtime environment capable
            of executing both client side and server side workloads. With its
            numerous advantages, including drastically reduced cold start times,
            efficiency, portability, and compatibility with the most popular
            programming languages today. It's currently supported by all major
            browsers. ticated and demanding Web applications such as interactive
            3D visualization, audio and video software, and games. With that,
            efficiency and security of code on the Web has become more important
            than ever. Yet JavaScript as the only built- in language of the Web
            is not well-equipped to meet these requirements, especially as a
            compilation target.
          </p>

          <p>
            <b>
              CCS Concepts • Software and its engineering → Virtual machines;
              Assembly languages; Webassembly;
            </b>
            Runtime environments; Just-in-time compiler
          </p>

          <p>
            Keywords Virtual machines, programming languages, as- sembly
            languages, just-in-time compilers, type system
          </p>

          <header class="heading-1">1. Introduction</header>
          <p>
            The Web began as a simple document exchange network but has now
            become the most ubiquitous application platform ever, accessible
            across a vast array of operating systems and
          </p>
        </section>
        <section>
          <p>
            device types. By historical accident, JavaScript is the only
            natively supported programming language on the Web, its widespread
            usage unmatched by other technologies avail- able only via plugins
            like ActiveX, Java or Flash. Because of JavaScript’s ubiquity, rapid
            performance improvements in modern VMs, and perhaps through sheer
            necessity, it has be- come a compilation target for other languages.
            Through Em- scripten [43], even C and C++ programs can be compiled
            to a stylized low-level subset of JavaScript called asm.js [4]. Yet
            JavaScript has inconsistent performance and a number of other
            pitfalls, especially as a compilation target.
          </p>
          <p>
            WebAssembly addresses the problem of safe, fast, portable low-level
            code on the Web. Previous attempts at solving it, from ActiveX to
            Native Client to asm.js, have fallen short of properties that a
            low-level compilation target should have:
          </p>
          <p>
            <b> Assertions as Boundaries around a Part: </b> An algorithm is
            broken into systems, subsystems, routines, and subroutines. You must
            be very clear about the goals of the overall algorithm and of each
            of these parts. Pre and postconditions are assertions that provide a
            clean boundary around each of these.
          </p>
          <ul>
            <li>Safe, fast, and portable semantics:</li>
            <ul>
              <li>safe to execute</li>
              <li>fast to execute</li>
              <li>language-, hardware-, and platform-independent</li>
              <li>deterministic and easy to reason about</li>
              <li>simple interoperability with the Web platform</li>
            </ul>
            <li>Safe and efficient representation:</li>
            <ul>
              <li>compact and easy to decode</li>
              <li>easy to validate and compile</li>
              <li>easy to generate for producers</li>
              <li>streamable and parallelizable</li>
            </ul>
          </ul>
          <p>Why are these goals important? Why are they hard</p>
          <p>
            Safe Safety for mobile code is paramount on the Web, since code
            originates from untrusted sources. Protection for mobile code has
            traditionally been achieved by providing a managed language runtime
            such as the browser’s JavaScript VM or a language plugin. Managed
            languages enforce mem- ory safety, preventing programs from
            compromising user data or system state. However, managed language
            runtimes have traditionally not offered much for portable low-level
            code, such as memory-unsafe compiled C/C++ applications that do not
            need garbage collection but are inherently fast
          </p>
        </section>
      </article>
    </page>
    <page size="A4">
      <article>
        <section>
          <p>
            Fast Low-level code like that emitted by a C/C++ compiler is
            typically optimized ahead-of-time. Native machine code, either
            written by hand or as the output of an optimizing com- piler, can
            utilize the full performance of a machine. Managed runtimes and
            sandboxing techniques have typically imposed a steep performance
            overhead on low-level code
          </p>
          <p>
            Portable The Web spans not only many device classes, but different
            machine architectures, operating systems, and browsers. Code
            targeting the Web must be hardware- and platform-independent to
            allow applications to run across all browser and hardware types with
            the same behavior. Previous solutions for low-level code were tied
            to a single architecture or have had other portability problems.
          </p>
          <p>
            Compact Code that is transmitted over the network should be as
            compact as possible to reduce load times, save poten- tially
            expensive bandwidth, and improve overall responsive- ness. Code on
            the Web is typically transmitted as JavaScript source, which is far
            less compact than a binary format, even when minified and
            compressed.
          </p>
          <header class="heading-2">
            1.1 Prior Attempts at Low-level Code on the Web
          </header>
          <p>
            Microsoft’s ActiveX[1] was a technology for code-signing x86
            binaries to run on the Web. It relied entirely upon code signing and
            thus did not achieve safety through technical construction, but
            through a trust model
          </p>
          <p>
            Native Client [42, 11] was the first system to introduce a
            sandboxing technique for machine code on the Web that runs at near
            native speed. It relies on static validation of x86 ma- chine code,
            requiring code generators to follow certain pat- terns, such as
            bitmasks before memory accesses and jumps. While the sandbox model
            allows NaCl code in the same process with sensitive data, the
            constraints of the Chrome browser led to an out-of-process
            implementation where NaCl code cannot synchronously access
            JavaScript or Web APIs. Because NaCl is a subset of a particular
            architecture’s machine code, it is inherently not portable. Portable
            Native Client (PNaCl) [18] builds upon the sandboxing techniques of
            NaCl and uses a stable subset of LLVM bitcode [24] as an interchange
            format, which addresses ISA portability. How- ever, it is not a
            significant improvement in compactness and still exposes compiler-
            or platform-specific details such as the layout of the call stack.
            NaCl and PNaCl are exclusively in Chrome, inherently limiting their
            applications’ portability.
          </p>
          <p>
            Emscripten [43] is a framework for compiling mostly un- modified
            C/C++ applications to JavaScript and linking them with an execution
            environment implemented in JavaScript. Emscripten compiles to a
            specialized subset of JavaScript that later evolved into asm.js [4],
            an embedded domain spe- cific language that serves as a
            statically-typed assembly- like language. Asm.js eschews the dynamic
            type system of JavaScript through additional type coercions coupled
            with a module-level validation of interprocedural invariants. Since
            asm.js is a proper subset of JavaScript, it runs on all JavaScript
            execution engines, benefiting from sophisticated JIT compilers, but
            it runs much faster in browsers with ded- icated support. Being a
            subset inherently ties it to JavaScrip
          </p>
        </section>

        <section>
          <p>
            semantics, and therefore extending asm.js with new features such as
            int64 requires first extending JavaScript and then blessing the
            extension in the asm.js subset. Even then it can be difficult to
            make the feature efficient
          </p>
          <p>
            While Java and Flash [2] came early to the Web and offered managed
            runtime plugins, neither supported high- performance low-level code,
            and today usage is declining due to security and performance issues.
            We discuss the dif- ferences between the JVM and WebAssembly in
            Section 8
          </p>

          <header>1.2 Contribution</header>

          <p>
            WebAssembly is the first solution for low-level code on the Web that
            delivers on all of the above design goals. It is the result of an
            unprecedented collaboration across major browser vendors and an
            online community group to build a common solution for
            high-performance applications. In this paper we focus on
          </p>
          <ul>
            <li>
              an overview of WebAssembly as a language that is the first truly
              cross-browser solution for fast low-level code,
            </li>
            <li>
              an in-depth discussion of its design, including insight into novel
              design decisions such as structured control flow,
            </li>
            <li>
              a complete yet concise formal semantics of both execu- tion and
              validation, including a proof of soundness,
            </li>
            <li>
              a report on implementation experience from developing production
              implementations in 4 major browsers, includ- ing novel techniques
              such as for memory protection
            </li>
          </ul>
          <p>
            To our knowledge, WebAssembly is the first industrial- strength
            language or VM that has been designed with a formal semantics from
            the start. This not only demonstrates the “real world” feasibility
            of such an approach, but also that it leads to a notably clean
            design.
          </p>
          <p>
            While the Web is the primary motivation for Web- Assembly, nothing
            in its design depends on the Web or a JavaScript environment. It is
            an open standard specifically designed for embedding in multiple
            contexts, and we expect that stand-alone implementations will become
            available in the future. The initial version primarily focuses on
            support- ing low-level languages, but we intend to grow it further
            in the future (Section 9).
          </p>
          <header class="heading-1">2. Overview</header>
          <p>
            Even though WebAssembly is a binary code format, we present it as a
            language with syntax and structure. This was an intentional design
            choice which makes it easier to explain and understand, without
            compromising compactness or ease of decoding. Figure 1 presents its
            structure in terms of abstract syntax.1 For brevity we omit a few
            minor features having to do with module initialization
          </p>
          <header class="heading-2">2.1 Basics</header>
          <p>
            Let us start by introducing a few unsurprising concepts be- fore we
            dive into less obvious ones in the following sections.
          </p>
        </section>
      </article>
    </page>
    <page size="A4">
      <figure>
        <section class="figure-table">
          <section>
            <div>(value types) t ::= i32 | i64 | f32 | f64</div>
            <div>(packed types) tp ::= i8 | i16 | i32</div>
            <div>(function types) tf ::= t∗ → t∗</div>
            <div>(global types) tg ::= mut? t</div>
            <div>unopiN ::= clz | ctz | popcnt</div>
            <div>
              unopfN ::= neg | abs | ceil | floor | trunc | nearest | sqrt
            </div>
            <!-- <div>binopiN ::= add | sub | mul | div sx | rem sx |</div>
                    <div>and | or | xor | shl | shr sx | rotl | rotr</div>
                    <div>binopfN ::= add | sub | mul | div | min | max | copysign</div>
                    <div>testopiN ::= eqz</div>
                    <div>relopiN ::= eq | ne | lt sx | gt sx | le sx | ge sx</div>
                    <div>relopfN ::= eq | ne | lt | gt | le | ge</div>
                    <div>cvtop ::= convert | reinterpret</div>
                    <div>sx ::= s | u</div> -->
          </section>

          <section>
            <div>(instructions) e ::= unreachable | nop | drop | select |</div>
            <div>block tf e∗ end | loop tf e∗ end | if tf e∗ else e∗ end |</div>
            <div>
              br i | br if i | br table i+ | return | call i | call indirect tf
              |
            </div>
            <div>get local i | set local i | tee local i | get global i |</div>
            <div>set global i | t.load (tp sx )? a o | t.store tp? a o |</div>
            <div>current memory | grow memory | t.const c |</div>
            <div>t.unopt | t.binopt | t.testopt | t.relopt | t.cvtop t sx</div>
          </section>

          <section>
            <div>unopiN ::= clz | ctz | popcnt</div>
            <div>
              unopfN ::= neg | abs | ceil | floor | trunc | nearest | sqrt
            </div>
            <div>binopiN ::= add | sub | mul | div sx | rem sx |</div>
            <div>and | or | xor | shl | shr sx | rotl | rotr</div>
            <div>binopfN ::= add | sub | mul | div | min | max | copysign</div>
            <div>testopiN ::= eqz</div>
            <div>relopiN ::= eq | ne | lt sx | gt sx | le sx | ge sx</div>
            <div>relopfN ::= eq | ne | lt | gt | le | ge</div>
            <!-- <div>cvtop ::= convert | reinterpret</div>
                    <div>sx ::= s | u</div> -->
          </section>

          <section>
            <div>
              (functions) f ::= ex ∗ func tf local t∗ e∗ | ex ∗ func tf im
            </div>
            <div>(globals) glob ::= ex ∗ global tg e∗ | ex ∗ global tg im</div>
            <div>(tables) tab ::= ex ∗ table n i∗ | ex ∗ table n im</div>
            <div>(memories) mem ::= ex ∗ memory n | ex ∗ memory n im</div>
            <div>(imports) im ::= import “name” “name”</div>
            <div>(exports) ex ::= export “name”</div>
            <div>(modules) m ::= module f ∗ glob∗ tab? mem</div>
          </section>
        </section>
        <hr />
        <figcaption><b>Figure 1.</b> WebAssembly abstract syntax</figcaption>
      </figure>
      <article>
        <section>
          <p>
            Modules A binary takes the form of a module. It con- tains
            definitions for functions, globals, tables, and memories. Each
            definition may be exported under one or more names. Definitions can
            also be imported, specifying a module/item name pair and a suitable
            type. Imports can be re-exported.
          </p>
          <p>
            While a module corresponds to the static representation of a
            program, an instance of a module corresponds to a dy- namic
            representation, complete with mutable memory and an execution stack.
            The instantiation operation for modules is provided by the embedder,
            such as a JavaScript virtual machine or an operating system.
            Instantiating a module re- quires providing definitions for all
            imports, which may be exports from previously created WebAssembly
            instances. WebAssembly computation can then be initiated by invok-
            ing a function exported from the instance.
          </p>
          <p>
            Functions The code in a module is organized into indi- vidual
            functions. Each function takes a sequence of Web- Assembly values as
            parameters and returns a sequence of values as results as defined by
            its function type. Functions can call each other, including
            recursively. Functions are not first class and cannot be nested
            within each other. As we will see later, the contents of the call
            stack for execution are not exposed, and thus cannot be directly
            accessed by a running WebAssembly program, even a buggy or malicious
            one.
          </p>
          <p>
            Instructions WebAssembly computation is based on a stack machine;
            code for a function consists of a sequence of instructions that
            manipulate values on an implicit operand stack, popping argument
            values and pushing result values. However, thanks to the type system
            (Section 4), the layout of the operand stack can be statically
            determined at any point in the code, so that actual implementations
            can compile the data flow between instructions directly without ever
            materi- alizing the operand stack.The stack organization is merely a
            way to achieve a compact program representation, as it has been
            shown to be smaller than a register machine [38].2
          </p>
        </section>
        <section>
          <p>
            traps Some instructions may produce a trap, which im- mediately
            aborts the current computation. Traps cannot cur- rently be handled
            by WebAssembly code, but an embed- der will typically provide means
            to handle this condition. Embedded in JavaScript, a WebAssembly trap
            will throw a JavaScript exception containing a stacktrace with both
            JavaScript and WebAssembly stack frames. It can be caught and
            inspected by the surrounding JavaScript code.
          </p>
          <p>
            Machine Types WebAssembly has only four basic value types t, all of
            which are available in common hardware. These are integers and IEEE
            754 floating point numbers, each in 32 and 64 bit width. 32 bit
            integers can be used as ad- dresses in the linear memory (Section
            2.2), and indexes into function tables (Section 2.4). Most
            WebAssembly instruc- tions simply execute operators on values of
            these basic data types. The grammar in Figure 1 conveniently
            distinguishes several categories, such as unary and binary
            operators, tests and comparisons. WebAssembly provides conversions
            be- tween all four types, and the ability to reinterpret the bits of
            values across equally-sized types. Like common hardware, WebAssembly
            has no distinction between signed and un- signed integer types.
            Instead, when the signedness of values matters to an instruction, a
            sign extension suffix u or s se- lects either unsigned or 2’s
            complement signed behavior
          </p>
          <p>
            Local Variables Functions f declare mutable local vari- ables of
            types t∗. Locals are zero-initialized and read or writ- ten by index
            via the get local and set local instructions, respectively; tee
            local allows writing a local variable while leaving the input value
            on the operand stack, which is very common in real code. The index
            space for local variables starts with and includes the function
            parameters, meaning that function parameters are also mutable
          </p>
          <hr class="half" />
          <footer>
            going so far as to field full-scale production prototypes and
            development tools for both representations. We found that post-order
            ASTs decode and verify faster than pre-order ASTs, but that the
            stack machine, which can be seen as a generalization of the
            post-order format, more easily extended to multi-value support and
            allowed even more space optimizations.
          </footer>
        </section>
      </article>
    </page>

    <page size="A4">
      <article>
        <section>
          <p>
            Global Variables A module may also declare typed global variables
            accessed with the get global and set global in- structions to read
            or write individual values. Globals can be either mutable or
            immutable and require an initializer which must be a constant
            expression that evaluates without access to any function, table,
            memory, local or mutable global. Im- porting globals and initializer
            expressions allow a limited form of configurability, e.g. for
            linking.
          </p>
          <p>
            So far so boring. In the following sections we turn our attention to
            more interesting or unusual features of the Web- Assembly semantics
          </p>
          <header class="heading-2">2.2 Linear Memor</header>
          <p>
            The main storage of a WebAssembly program is a large array of bytes
            referred to as a linear memory or simply memory
          </p>
          <p>
            Creation and Growing Each module can define at most one memory,
            which may be shared with other instances via import/export. Memory
            is created with an initial size but may be dynamically grown with
            the grow memory in- struction. Growing may fail with an
            out-of-memory condi- tion indicated by grow memory returning −1 to
            be han- dled by the program.3 The size can be queried with the
            current memory instruction. The unit of size and growth is a page,
            which is defined to be 64 KiB, the least com- mon multiple of
            minimum page sizes on modern hardware. The page size allows reusing
            virtual memory hardware for bounds checks (Section 7). Page size is
            fixed instead of be- ing system-specific to prevent a common
            portability hazard.
          </p>
          <p>
            Access Memory is accessed with load and store instruc- tions that
            take a static alignment exponent a, a positive static offset o, an
            optional static width expressed as a packed type tp, and the dynamic
            i32 address. Addresses are simply un- signed integers starting at 0.
            The effective address of an ac- cess is the sum of the 32 bit static
            offset o and the dynamic i32 address as a 33 bit address (i.e., no
            wraparound), which allows specific optimizations (Section 7). All
            memory ac- cess is dynamically checked against the memory size; out
            of bounds access results in a trap. Memory can be accessed with 8,
            16, 32, or 64 bit wide loads and stores, with packed integer loads
            performing a zero or sign extension sx to either 32 or 64 bits.
            Unaligned access, where 2a is smaller than the (packed) type’s
            width, is supported, e.g. accessing a 32 bit value on an odd
            address. Such access may be slow on some platforms, but always
            produces the same unexciting results.
          </p>
          <p>
            Endianness Byte order in memory is observable to pro- grams that
            load and store to aliased locations with differ- ent types.
            Contemporary hardware seems to be converging on little-endian byte
            order, either being natively little-endian or having optional endian
            conversion included in memory access, or being architecturally
            neutral with both variants available. Recognizing this convergence,
            we chose to de- fine WebAssembly memory to have little-endian byte
            orde
          </p>
          <hr class="half" />
          <footer>
            <sup>3</sup> To support additional optimizations, WebAssembly also
            allows declaring an upper limit for each memory’s size, which we
            omit in this presentation.
          </footer>
        </section>

        <section>
          <p>
            Of course, that entails that big-endian platforms require ex- plicit
            endian conversions. However, these conversions can be subjected to
            classical compiler optimizations such as re- dundancy elimination
            and code motion by the WebAssembly engine. Thus the semantics of
            memory access is completely deterministic and portable across all
            engines and platforms, even for unaligned accesses and unrestricted
            type-punning
          </p>
          <p>
            Security Linear memory is disjoint from code space, the execution
            stack, and the engine’s data structures; therefore compiled programs
            cannot corrupt their execution environ- ment, jump to arbitrary
            locations, or perform other undefined behavior. At worst, a buggy or
            exploited WebAssembly pro- gram can make a mess of the data in its
            own memory. This means that even untrusted modules can be safely
            executed in the same address space as other code. Achieving fast in-
            process isolation was a necessary design constraint for inter-
            acting with untrusted JavaScript and the full complement of Web APIs
            in a high-performance way. It also allows a Web- Assembly engine to
            be embedded into any other managed language runtime without
            violating memory safety, as well as enabling programs with many
            independent instances with their own memory to exist in the same
            process.
          </p>
          <header class="heading-2">2.3 Structured Control Flow</header>
          <p>
            WebAssembly represents control flow differently from most stack
            machines. It does not offer simple jumps but instead provides
            structured control flow constructs more akin to a programming
            language. This ensures by construction that control flow cannot form
            irreducible loops, contain branches to blocks with misaligned stack
            heights, or branch into the middle of a multi-byte instruction.
            These properties allow WebAssembly code to be validated in a single
            pass, com- piled in a single pass, or even transformed to an
            SSA-form intermediate form in a single pass. Structured control flow
            disassembled to a text format is also easier to read, an often
            overlooked but important human factor on the web, where users are
            accustomed to inspecting the code of Web pages to learn and share in
            an open manner.
          </p>
          <p>
            Control Constructs and Blocks As required by the gram- mar in Figure
            1, the block, loop and if constructs must be terminated by an end
            opcode and be properly nested to be considered well-formed. The
            inner instruction sequences e∗ in these constructs form a block.
            Note that loop does not au- tomatically iterate its block but allows
            constructing a loop manually with explicit branches. The if
            construct encloses two blocks separated by an else opcode. The else
            can be omitted if the second block is empty. Executing an if pops an
            i32 operand off the stack and executes one of the blocks depending
            on whether the value is non-zero
          </p>
          <p>
            Branches and Labels Branches have “label” immediates that do not
            reference program positions in the instruction stream but instead
            reference outer control constructs by rel- ative nesting depth. That
            means that labels are effectively scoped: branches can only
            reference constructs in which they are nested. Taking a branch
            “breaks from” that con-
          </p>
        </section>
      </article>
    </page>

    <page size="A4">
      <article>
        <section>
          <p>
            struct’s block; 4 the exact effect depends on the target con-
            struct: in case of a block or if it is a forward jump, resuming
            execution after the matching end (like a break statement); with a
            loop it is a backward jump, restarting the loop (like a continue
            statement)
          </p>
          <p>
            The br if instruction branches if its input is non-zero, and br
            table selects a target from a list of label immediates based on an
            index operand, with the last label being the target for
            out-of-bounds index values. These two instructions allow minimal
            code that avoids any jumps-to-jumps.
          </p>
          <p>
            Block Signatures and Unwinding Every control construct is annotated
            with a function type tf = t∗ 1 → t∗ 2 that de- scribes how it
            changes the stack.5 Conceptually, blocks ex- ecute like function
            calls. Each block pops its argument val- ues t∗ 1 off the stack,
            creates a new stack, pushes the argu- ments onto the new stack,
            executes, pops its results off the internal stack, and then pushes
            its results t∗ 2 onto the outer stack. Since the beginning and end
            of a block represent con- trol join points, all branches must also
            produce compatible stacks. Consequently, branch instructions
            themselves expect operands, depending on whether they jump to the
            start or end of the block, i.e., with types t∗ 1 for loop targets
            and t∗ 2 for block or if
          </p>
          <p>
            ranching unwinds a block’s local operand stack by im- plicitly
            popping all remaining operands, similar to returning from a function
            call. When a branch crosses several block boundaries, all respective
            stacks up to and including the tar- get block’s are unwound. This
            liberates producers from hav- ing to track stack height across
            sub-expressions in order to make them match up at branches by adding
            explicit drops.
          </p>

          <p>
            Production implementations perform register allocation and compile
            away the operand stack when generating ma- chine code. However, the
            design still allows simple inter- preters, e.g., to implement
            debuggers. An interpreter can have a contiguous stack and just
            remember the height upon entry to each block in a separate control
            stack. Further, it can make a prepass to construct a mapping from
            branches to in- struction position and avoid dynamically searching
            for end opcodes, making all interpreter operations constant-time.
            <sup>6</sup>
          </p>

          <p>
            Expressiveness Structured control flow may seem like a severe
            limitation. However, most control constructs from higher-level
            languages are readily expressible with the suit- able nesting of
            blocks. For example, a C-style switch state- ment with fall-through,
          </p>

          <section class="code">
            <pre>
                        <code>
switch (x) {
    case 0: ...A...
    case 1: ...B... break;
    default: ...C...
    }
                        </code>
                    </pre>

            <div>becomes</div>

            <pre>
                        <code>
block block block block
br table 0 1 2
end ...A...
end ...B... br 1
end ...C...
end
</code>
                    </pre>
          </section>

          <p>Slightly more finesse is required for fall-through between</p>
          <hr class="half" />
          <footer>
            <div>
              <sup>4</sup> The instruction name br can also be read as “break”
              wrt. to a block
            </div>
            <div>
              <sup>5</sup> In the initial version of WebAssembly, t∗<sub>1</sub>
              must be empty and |t<sup>∗</sup><sub>2</sub> | ≤ 1
            </div>
            <div>
              <sup>6</sup> That is the approach V8 takes in its debugging
              interpreter.
            </div>
          </footer>
        </section>

        <section>
          <p>
            unordered cases. Various forms of loops can likewise be expressed
            with combinations of loop, block, br and br if.
          </p>
          <p>
            By design, unstructured and irreducible control flow us- ing goto is
            impossible in WebAssembly. It is the responsi- bility of producers
            to transform unstructured and irreducible control flow into
            structured form. This is the established ap- proach to compiling for
            the Web (e.g. the relooper algo- rithm [43]), where JavaScript is
            also restricted to structured control. In our experience building an
            LLVM backend for WebAssembly, irreducible control flow is rare, and
            a sim- ple restructuring algorithm is all that is necessary to
            trans- late any CFG to WebAssembly. The benefit of requiring re-
            ducible control flow by construction is that many algorithms in
            consumers are much simpler and faster.
          </p>
          <header class="heading-2">2.4 Function Calls and Tables</header>

          <p>
            A function body is a block (Section 2.3) whose signature maps the
            empty stack to the function’s result. The arguments to a function
            are stored in the first local variables of the func- tion. Execution
            of a function can complete in one of three ways: (1) by reaching the
            end of the block, in which case the operand stack must match the
            function’s result types; (2) by a branch targeting the function
            block, with the result val- ues as operands; (3) by executing
            return, which is simply shorthand for a branch that targets the
            function’s block.
          </p>

          <p>
            Direct Calls Functions can be invoked directly using the call
            instruction which takes an index immediate identifying the function
            to call. The call instruction pops the function arguments from the
            operand stack and pushes the function’s return values upon return.
          </p>

          <p>
            Indirect Calls Function pointers can be emulated with the call
            indirect instruction which takes a runtime index into a global table
            of functions defined by the module. The func- tions in this table
            are not required to have the same type. Instead, the type of the
            function is checked dynamically against an expected type supplied to
            the call indirect in- struction. The dynamic signature check
            protects integrity of the execution environment; a successful
            signature check en- sures that a single machine-level indirect jump
            to the com- piled code of the target function is safe. In case of a
            type mismatch or an out of bounds table access, a trap occurs. The
            heterogeneous nature of the table is based on experi- ence with
            asm.js’s multiple homogeneous tables; it allows more faithful
            representation of function pointers and simpli- fies dynamic
            linking. To aid dynamic linking scenarios fur- ther, exported tables
            can be grown and mutated dynamically through external APIs.
          </p>

          <p>
            External and Foreign Calls Functions can be imported to a module and
            are specified by name and signature. Both direct and indirect calls
            can invoke an imported function, and through export/import, multiple
            module instances can communicate.
          </p>

          <p>
            Additionally, the import mechanism serves as a safe for- eign
            function interface through which a WebAssembly pro- gram can
            communicate with its embedding environment. For
          </p>
        </section>
      </article>
    </page>

    <page size="A4">
      <article>
        <section>
          example, when WebAssembly is embedded in JavaScript, imported
          functions may be host functions that are defined in JavaScript. Values
          crossing the language boundary are auto- matically converted according
          to JavaScript rules.
        </section>
      </article>
    </page>

    <style>
      .ref::before {
        content: "[" attr(number) "]";
        display: inline-block;
      }
      .ref {
        display: flex;
        margin: 1em 0;
        gap: 1em;
      }
    </style>

    <page size="A4">
      <article>
        <section>
          <div class="ref" number="11">
            <div>
              j . Ansel, P. Marchenko, U. Erlingsson, E. Taylor, B. Chen, D. L.
              Schuff, D. Sehr, C. L. Biffle, and B. Yee. Languageindependent
              sandboxing of just-in-time compilation and selfmodifying code. In
              Proceedings of the ACM SIGPLAN Conference on Programming Language
              Design and Implementation, PLDI ’11, pages 355–366, New York, NY,
              USA, 2011. ACM.
            </div>
          </div>

          <div class="ref" number="12">
            <div>
              N. G. de Bruijn. Lambda calculus notation with nameless dummies: a
              tool for automatic formula manipulation with application to the
              Church-Rosser theorem. Indag. Math., 34:381–392, 1972.
            </div>
          </div>
        </section>

        <section>
          <div class="ref" number="13">
            <div>
              J. Criswell, A. Lenharth, D. Dhurjati, and V. Adve. Secure Virtual
              Architecture: A safe execution environment for commodity operating
              systems. SIGOPS Oper. Syst. Rev., 41(6):351–366, Oct. 2007.
            </div>
          </div>
        </section>
      </article>
    </page>
  </body>
</html>
